#!/usr/bin/env ipython_wrapper
# -*- coding: utf-8 -*-
from __future__ import print_function, division, absolute_import, unicode_literals
import argparse, os
from os import path
import numpy as np


if __name__ == '__main__':
    import script_utils # Append mripy to Python path
    from mripy import afni, utils, io, surface
    timer = script_utils.ScriptTimer()

    parser = argparse.ArgumentParser(description='Compute cortical depth.')
    parser.add_argument('-b', '--base', required=True, help='grid parent')
    parser.add_argument('-s', '--suma', default='../SUMA', help='SUMA directory (default ../SUMA)')
    parser.add_argument('-v', '--surf_vol', default='SurfVol_Alnd_Exp+orig', help='SurfVol (default SurfVol_Alnd_Exp+orig)')
    parser.add_argument('-m', '--method', default='equivolume', help='method for depth estimation ([equivolume]|3dSurfMask)')
    parser.add_argument('-o', '-prefix', '--prefix', default=None, help='output prefix (default <base>.depth)')
    parser.add_argument('-j', '--jobs', type=int, default=4, help='number of parallel processes: [4]|8|12|...')
    args = parser.parse_args()
    spec = afni.get_suma_info(args.suma)['spec']
    hemis = ['lh', 'rh']
    prefix = afni.get_prefix(args.base) if args.prefix is None else args.prefix
    depth_out = prefix + '.depth'
    weight_out = prefix + '.weight'
    temp_folder = utils.temp_prefix(suffix='')
    os.makedirs(temp_folder)
    pc = utils.PooledCaller(pool_size=args.jobs)

    # Calculate relative depth (equidistance) for current args.base, if necessary (could take hours...)
    if not utils.exists(depth_out + '+orig.HEAD'): # Prevent unexpected overwrite
        if args.method.lower() == '3dsurfmask':
            pc = utils.PooledCaller(pool_size=4)
            for hemi in hemis:
                for surface in ['smoothwm', 'pial']:
                    print('>> Computing tmp.{0}.{1}.{2}+orig'.format(depth_out, hemi, surface))
                    n_chunks = max(1, args.jobs//4)
                    # The specific algorithm used by ``3dSurfMask`` requires us to divide the volume
                    # only along the slice dimension, so that the surface remain "closed" within the subvolume.
                    pc.check_call(utils.parallel_3D, ['3dSurfMask',
                        '-spec', spec[hemi],
                        '-surf', surface,
                        '-sv', args.surf_vol,
                        '-grid_parent', '{in_file}',
                        '-fill_method', 'FAST',
                        '-prefix', '{depth_out}', '-overwrite'], 
                        in_file=args.base, prefix='.'.join(('tmp', depth_out, hemi, surface)), 
                        n_jobs=n_chunks, schema=[1,1,n_chunks], fname_mapper={'_out': '_out.m'})
            pc.wait()
            for hemi in hemis:
                # Calculate relative depth for the whole volume
                !3dcalc -a tmp.{depth_out}.{hemi}.smoothwm+orig -b tmp.{depth_out}.{hemi}.pial+orig \
                    -expr '-a/(b-a)' -prefix tmp.{depth_out}.{hemi} -overwrite
                # Keep only near-surface voxels
                !3dcalc -a tmp.{depth_out}.{hemi}+orig -b tmp.{depth_out}.{hemi}.pial+orig \
                    -expr 'a*step(a+0.5)*step(1.5-a)*step(5-b)*step(b+1)' \
                    -prefix tmp.{depth_out}.{hemi} -overwrite
        elif args.method.lower() == 'equivolume':
            depths = np.r_[np.linspace(-0.2, 1.1, 14)+0.05]
            alphas = np.r_[np.linspace(-0.2, 1.2, 15)] # Native jobs = 14~15 (so jobs=8 is good)
            n_laminae = len(depths)
            lamina_names = {}
            lamina_files = {}
            inner = {}
            outer = {}
            for hemi in hemis:
                lamina_names[hemi] = []
                lamina_files[hemi] = []
                inner[hemi] = io.read_asc(path.join(args.suma, '{0}.smoothwm.asc'.format(hemi)))
                outer[hemi] = io.read_asc(path.join(args.suma, '{0}.pial.asc'.format(hemi)))
                for k, alpha in enumerate(alphas):
                    lamina_names[hemi].append('{0}.L{1:02d}.asc'.format(hemi, k))
                    lamina_files[hemi].append(path.join(temp_folder, lamina_names[hemi][k]))
                    pc.check_call(surface.intermediate_asc, lamina_files[hemi][k], inner[hemi], outer[hemi], alpha, method='equivolume_inside')
            pc.wait()
            # Generate spec files
            lamina_spec = {hemi: path.join(temp_folder, 'lamina_{0}.spec'.format(hemi)) for hemi in hemis}
            for hemi in hemis:
                afni.generate_spec(lamina_spec[hemi], lamina_names[hemi])
            # Project surface to volume
            weight1_files = {}
            for hemi in hemis:
                weight1_files[hemi] = []
                for k in range(n_laminae):
                    weight1_files[hemi].append(path.join(temp_folder, '{0}.w{1:02d}+orig.HEAD'.format(hemi, k)))
                    pc.check_call(['3dSurf2Vol',
                        '-spec', lamina_spec[hemi],
                        '-surf_A', lamina_names[hemi][k],
                        '-surf_B', lamina_names[hemi][k+1],
                        '-sv', args.surf_vol,
                        '-grid_parent', args.base,
                        '-map_func', 'count',
                        '-f_steps', '20',
                        '-f_index', 'nodes',
                        '-prefix', weight1_files[hemi][k], 
                        '-overwrite'])
            pc.wait()
            # Project lamina thickness to volume
            def compute_thickness(fname, inner, outer):
                vin, fin = io.read_asc(inner)
                vout, fout = io.read_asc(outer)
                d = np.linalg.norm(vout - vin, axis=-1)
                io.write_1D_nodes(fname, None, d)
            thick_1Ds = {}
            for hemi in hemis:
                thick_1Ds[hemi] = []
                for k in range(n_laminae):
                    thick_1Ds[hemi].append(path.join(temp_folder, '{0}.t{1:02d}.1D'.format(hemi, k)))
                    pc.check_call(compute_thickness, thick_1Ds[hemi][k], lamina_files[hemi][k], lamina_files[hemi][k+1])
            pc.wait()
            thick_files = {}
            for hemi in hemis:
                thick_files[hemi] = []
                for k in range(n_laminae):
                    thick_files[hemi].append(path.join(temp_folder, '{0}.T{1:02d}+orig.HEAD'.format(hemi, k)))
                    pc.check_call(['3dSurf2Vol',
                        '-spec', lamina_spec[hemi],
                        '-surf_A', lamina_names[hemi][k],
                        '-surf_B', lamina_names[hemi][k+1],
                        '-sv', args.surf_vol,
                        '-grid_parent', args.base,
                        '-sdata_1D', thick_1Ds[hemi][k],
                        '-map_func', 'ave',
                        '-f_steps', '20',
                        '-f_index', 'nodes',
                        '-prefix', thick_files[hemi][k], 
                        '-overwrite'])
            pc.wait()
            # Weighted sum
            weight_files = {}
            for hemi in hemis:
                weight_files[hemi] = []
                for k in range(n_laminae):
                    weight_files[hemi].append(path.join(temp_folder, '{0}.W{1:02d}+orig.HEAD'.format(hemi, k)))
                    pc.check_call(f'''3dcalc -a {weight1_files[hemi][k]} -b {thick_files[hemi][k]} \
                        -expr 'a*b' -prefix {weight_files[hemi][k]} -overwrite
                        ''', shell=True)
            pc.wait()
            wsum_files = {}
            for hemi in hemis:
                wsum_files[hemi] = path.join(temp_folder, '{0}.WSum+orig.HEAD'.format(hemi))
                pc.check_call(['3dTstat', '-sum', '-prefix', wsum_files[hemi], '-overwrite',
                    '"{0}"'.format(' '.join(weight_files[hemi]))], shell=True)
            pc.wait()
            depth_files = {}
            for hemi in hemis:
                depth_files[hemi] = []
                for k in range(n_laminae):
                    depth_files[hemi].append(path.join(temp_folder, '{0}.D{1:02d}+orig.HEAD'.format(hemi, k)))
                    pc.check_call(f'''
                        3dcalc -a {weight_files[hemi][k]} -b {wsum_files[hemi]} \
                            -expr 'a/b' -prefix {weight_files[hemi][k]} -overwrite;
                        3dcalc -a {weight_files[hemi][k]} \
                            -expr 'a*{depths[k]:.3f}' -prefix {depth_files[hemi][k]} -overwrite;
                        ''', shell=True)
            pc.wait()
            for hemi in hemis:
                pc.check_call(f'''
                    3dTstat -sum -prefix tmp.{depth_out}.{hemi} -overwrite "{' '.join(depth_files[hemi])}";
                    3dTcat -prefix tmp.{weight_out}.{hemi} -overwrite "{' '.join(weight_files[hemi])}";
                    ''', shell=True)
            pc.wait()
        
        # Combine left and right hemisphere
        !3dcalc -l tmp.{depth_out}.lh+orig -r tmp.{depth_out}.rh+orig \
            -expr 'l+r' -prefix {depth_out} -overwrite
        !3dcalc -l tmp.{weight_out}.lh+orig -r tmp.{weight_out}.rh+orig \
            -expr 'max(l,r)' -prefix {weight_out} -overwrite

    # Check successful
    if pc.all_successful():
        print('>> Depth estimation was done without error.')
    else:
        print('>> Sorry, but something went wrong in the middle...')

    # Remove temp files
    !rm tmp.*
