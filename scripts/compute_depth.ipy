#!/usr/bin/env ipython --
# -*- coding: utf-8 -*-
from __future__ import print_function, division, absolute_import, unicode_literals
import sys, os, argparse, glob, re
from os import path
import numpy as np
from mypy import mypy

# https://github.com/mikedh/trimesh

if __name__ == '__main__':
    import script_utils # Append mripy to Python path
    from mripy import afni, utils, io
    timer = script_utils.ScriptTimer()

    parser = argparse.ArgumentParser(description='')
    # parser.add_argument('-i', '-input', '-roi', '--roi', required=True, nargs='+', help='surface ROI(s)')
    parser.add_argument('-b', '-base', '--base', required=True, help='grid parent')
    parser.add_argument('-s', '--suma', default='../SUMA', help='SUMA directory (default ../SUMA)')
    parser.add_argument('-v', '--surf_vol', default='SurfVol_Alnd_Exp+orig', help='SurfVol (default SurfVol_Alnd_Exp+orig)')
    # parser.add_argument('-c', '--combine', action='store_true', help='combine ROIs to get a single mask')
    # parser.add_argument('-o', '-output', '-prefix', '--prefix', default=None, help='output prefix (default as 1st ROI)')
    args = parser.parse_args()
    suma_path = path.expanduser(args.suma)
    suma_subj = afni.get_suma_subj(suma_path)
    # rois = [path.basename(roi)[:-9] for roi in args.roi] # Remove extension *.niml.roi
    # hemis = [re.search(r'\b([lr]h)\b', roi).group(1) for roi in rois] # Hint for lh/rh in fname
    # if args.prefix is None:
    #     args.prefix = re.sub(r'(\W|_)?[lr]h', '', rois[0])
    # cb = 'tmp.' if args.combine else ''
    depth_range = [0, 1]

    print(f"{suma_path}/{suma_subj}_{'lh'}.spec")
    # Extract voxel list from the masked volume
    mask = io.Mask(args.base)
    if not utils.exists('tmp.xyz_list.1D'): # Lazy evaluation
        np.savetxt(fname, mask.xyz, fmt='%g')
    index = {}
    dist = {}
    distvec = {}
    k1 = {}
    k2 = {}
    normal = {}
    surfs = ['smoothwm', 'pial'] # in, out
    hemis = ['lh', 'rh']
    for surf in surfs:
        for hemi in hemis:
            prefix = 'tmp.{0}.{1}'.format(surf, hemi)
            # For each voxel in the list, find closest node on the surface
            # *.closest.1D.dset: 0: node index, 1: distance, 2-4: voxel xyz, 5-7: node xyz
            fname = prefix + '.closest.1D.dset'
            if not utils.exists(fname): # Lazy evaluation
                utils.parallel_1D('SurfaceMetrics -prefix {{prefix}} -overwrite \
                    -i "{surf}" -sv "{sv}" -closest_node {{in_file}}'.format(
                        surf='{0}/{1}.{2}.asc'.format(suma_path, hemi, surf), sv=args.surf_vol),
                    'tmp.xyz_list.1D', prefix, n_jobs=12)
            # Compute distance vector orientation
            x = np.loadtxt(fname)
            index[hemi] = np.int_(x[:,0]) # Index of the closest node
            dist[hemi] = x[:,1] # Distance to the closest node
            distvec[hemi] = (x[:,5:8] - x[:,2:5]) / x[:,1:2] # Unit vector
            # For each node on the surface, compute normal vector and curvature
            # (*.NodeNormSeg.1D): coordinates of the two end-points of the normal
            # *.NodeNorm.1D.do: node index + normal unit vector
            # *.curv.1D.dset: 0: index, 1-6: 1st/2nd principal directions, 7/8: k1/k2 9: norm(k1,k2)
            # (*.curv.niml.dset): same as 1D.dset, but encoded
            # (*.curv.1D.do): 1st/2nd principal directions
            fname = prefix + '.curv.1D.dset'
            if not utils.exists(fname): # Lazy evaluation, although this op is quite fast
                !SurfaceMetrics -prefix {prefix} -overwrite \
                    -i "{suma_path}/{hemi}.{surf}.asc" -sv "{args.surf_vol}" \
                    -node_normals -curv
            # Load normal and curvature of the closest node
            x = np.loadtxt(fname)
            k1[hemi] = x[index[hemi],7]
            k2[hemi] = x[index[hemi],8]
            x = np.loadtxt(prefix + '.NodeNorm.1D.do')
            normal[hemi] = x[index[hemi],1:]
        # For each voxel in the list, merge closest node results from the two hemispheres
        closest = (dist[hemis[0]] < dist[hemis[1]])
        index[surf] = np.where(closest, index[hemis[0]], index[hemis[1]])
        dist[surf] = np.where(closest, dist[hemis[0]], dist[hemis[1]])
        distvec[surf] = np.where(closest[:,np.newaxis], distvec[hemis[0]], distvec[hemis[1]]) # Enable broadcasting
        k1[surf] = np.where(closest, k1[hemis[0]], k1[hemis[1]])
        k2[surf] = np.where(closest, k2[hemis[0]], k2[hemis[1]])
        normal[surf] = np.where(closest[:,np.newaxis], normal[hemis[0]], normal[hemis[1]])
    mypy.saveObjectAsPickle(dict(index=index, dist=dist, distvec=distvec, k1=k1, k2=k2, normal=normal), 'test.pickle')
    # Combine results for the two surfaces
    sign_ = np.where(np.sum(distvec[surfs[0]] * distvec[surfs[1]], axis=1) < 0,
        0, np.where(dist[surfs[0]] < dist[surfs[1]], -1, 1))
    d = np.where(sign_ == 0, dist[surfs[0]] + dist[surfs[1]],
        np.abs(dist[surfs[0]] - dist[surfs[1]]))
    rho = np.where(sign_ < 0, -dist[surfs[0]], dist[surfs[0]]) / d
    rho[(rho < depth_range[0]) | (rho > depth_range[1])] = 0
    # Compute equi-volume distance
    Ain = 1 / ((1 + 0.5 * np.sign(k1[surfs[0]]-k1[surfs[1]]) * d * k1[surfs[0]]) *
               (1 + 0.5 * np.sign(k2[surfs[0]]-k2[surfs[1]]) * d * k2[surfs[0]]))
    Aout = 1 / ((1 + 0.5 * np.sign(k1[surfs[1]]-k1[surfs[0]]) * d * k1[surfs[1]]) *
                (1 + 0.5 * np.sign(k2[surfs[1]]-k2[surfs[0]]) * d * k2[surfs[1]]))
    alpha = (rho**2 * Aout - (1-rho)**2 * Ain + Ain) / (Aout + Ain)
    assert(np.allclose(alpha, ((rho*(Aout-Ain)+Ain)**2-Ain**2)/(Aout**2-Ain**2)))
    # Write output
    mask.undump('depth_equidistance', rho)
    mask.undump('depth_equivolume', alpha)

    # Remove temp files
    # !rm tmp.*
