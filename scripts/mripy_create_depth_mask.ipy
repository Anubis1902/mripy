#!/usr/bin/env ipython_wrapper
# -*- coding: utf-8 -*-
from __future__ import print_function, division, absolute_import, unicode_literals
import sys, os, argparse, glob, re
from os import path


if __name__ == '__main__':
    import script_utils # Append mripy to Python path
    from mripy import afni, utils
    timer = script_utils.ScriptTimer()

    parser = argparse.ArgumentParser(description='Create depth mask from surface ROI.')
    parser.add_argument('-i', '-input', '-roi', '--roi', required=True, nargs='+', help='surface ROI(s)')
    parser.add_argument('-b', '-base', '--base', required=True, help='grid parent')
    parser.add_argument('-s', '--suma', default='../SUMA', help='SUMA directory (default ../SUMA)')
    parser.add_argument('-v', '--surf_vol', default='SurfVol_Alnd_Exp+orig', help='SurfVol (default SurfVol_Alnd_Exp+orig)')
    # parser.add_argument('-m', '--method', default='3dSurfMask', help='method for mask generation (default 3dSurfMask)')
    parser.add_argument('-c', '--combine', action='store_true', help='combine ROIs to get a single mask')
    parser.add_argument('-o', '-output', '-prefix', '--prefix', default=None, help='output prefix (default as 1st ROI)')
    args = parser.parse_args()
    suma_dir = path.expanduser(args.suma)
    suma_subj = afni.get_suma_subj(suma_dir)
    rois = [path.basename(roi)[:-9] for roi in args.roi] # Remove extension *.niml.roi
    hemis = [re.search(r'\b([lr]h)\b', roi).group(1) for roi in rois] # Hint for lh/rh in fname
    if args.prefix is None:
        args.prefix = re.sub(r'(\W|_)?[lr]h', '', rois[0])
    cb = 'tmp.' if args.combine else ''

    # Convert *.niml.roi to *.niml.dset
    for k, roi in enumerate(args.roi):
        !ROI2dataset -prefix tmp.{rois[k]} -overwrite -input $roi

    # Create non-depth-dependent masks
    # Use -f_steps 10 to avoid getting hollow mask. However, the mask is bulky, and still has holes.

    print('>> Creating depth-independent masks...')
    for k, roi in enumerate(rois):
        !3dSurf2Vol \
            -spec $suma_dir/{suma_subj}_{hemis[k]}.spec \
            -surf_A smoothwm \
            -surf_B pial \
            -sv $args.surf_vol \
            -grid_parent $args.base \
            -sdata tmp.{roi}.niml.dset \
            -f_steps 10 \
            -f_p1_fr -0.2 \
            -f_pn_fr 0.1 \
            -map_func mask2 \
            -prefix {cb}{roi}.mask -overwrite

    # Calculate relative depth for current args.base, if necessary (could take hours...)
    # However, there are also holes in the resulting PREFIX.d datasets
    prefix = afni.get_prefix(args.base) + '.depth'
    if path.exists(prefix + '+orig.HEAD'):
        print('>> Reuse {0}'.format(prefix))
    else:
        pc = utils.ParallelCaller() # Execute 4 instances of 3dSurfMask in parallel
        for hemi in ['lh', 'rh']:
            for surface in ['smoothwm', 'pial']:
                print('>> Computing tmp.{0}.{1}.{2}.d+orig'.format(prefix, hemi, surface))
                pc.check_call(['3dSurfMask', \
                    '-spec', '{0}/{1}_{2}.spec'.format(suma_dir, suma_subj, hemi),
                    '-surf', surface,
                    '-sv', args.surf_vol,
                    '-grid_parent', args.base,
                    '-fill_method', 'FAST',
                    '-prefix', '.'.join(('tmp', prefix, hemi, surface)), '-overwrite'])
        pc.wait() # Wait for all 3dSurfMask instances
        for hemi in ['lh', 'rh']:
            # Calculate relative depth for the whole volume
            !3dcalc -a tmp.{prefix}.{hemi}.smoothwm.d+orig -b tmp.{prefix}.{hemi}.pial.d+orig \
                -expr '-a/(b-a)' -prefix tmp.{prefix}.{hemi} -overwrite
            # Keep only near-surface voxels
            !3dcalc -a tmp.{prefix}.{hemi}+orig -b tmp.{prefix}.{hemi}.pial.d+orig \
                -expr 'a*step(a+0.5)*step(1.5-a)*step(5-b)*step(b+1)' \
                -prefix tmp.{prefix}.{hemi} -overwrite
        # Combine left and right hemisphere
        !3dcalc -l tmp.{prefix}.lh+orig -r tmp.{prefix}.rh+orig \
            -expr 'l+r' -prefix $prefix -overwrite

    # Create depth-dependent masks
    print('>> Creating depth-dependent masks...')
    for k, roi in enumerate(rois):
        !3dcalc -a {cb}{roi}.mask+orig -b $prefix+orig \
            -expr 'step(a)*b' -prefix {cb}{roi}.depth -overwrite

    if args.combine:
        print('>> Combine ROIs')
        for suffix in ['mask', 'depth']:
            !3dbucket -prefix -overwrite tmp.combine.{suffix} {' '.join(['%s%s.%s+orig' % (cb, roi, suffix) for roi in rois])}
            !3dTstat -sum -prefix {args.prefix}.{suffix} -overwrite tmp.combine.{suffix}+orig

    # Remove temp files
    !rm tmp.*
